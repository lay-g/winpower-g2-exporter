package config

// Config 统一配置接口定义了所有模块配置必须实现的基础功能。
// 这个接口确保了配置的一致性和可测试性，为模块化配置管理提供了标准契约。
//
// 设计原则：
// - 每个模块的配置结构都应实现此接口
// - 验证逻辑应该在 Validate 方法中实现
// - 默认值应该在 SetDefaults 方法中设置
// - String 方法应脱敏处理敏感信息
type Config interface {
	// Validate 验证配置的有效性。
	// 此方法应该检查所有必需字段、格式验证、业务规则等。
	// 如果配置无效，应该返回具体的错误信息；如果配置有效，返回 nil。
	//
	// 示例验证内容：
	//   - 必需字段是否已设置
	//   - 字段值是否在有效范围内
	//   - 字段格式是否正确（如URL、路径等）
	//   - 字段间的依赖关系是否满足
	//
	// 返回：
	//   - error: 配置验证错误，nil 表示验证通过
	Validate() error

	// SetDefaults 设置配置的默认值。
	// 此方法应该为所有可空字段设置合理的默认值。
	// 这个方法通常在配置加载后但在验证前调用。
	//
	// 设计原则：
	//   - 默认值应该是安全和常用的选择
	//   - 优先使用环境变量，然后是配置文件，最后是默认值
	//   - 考虑生产环境的最佳实践
	//   - 为敏感字段提供安全的默认值
	SetDefaults()

	// String 返回配置的字符串表示。
	// 此方法用于日志记录和调试，必须对敏感信息进行脱敏处理。
	//
	// 敏感信息处理原则：
	//   - 密码、令牌等应替换为 "***" 或 "<hidden>"
	//   - 保留足够的信息用于调试
	//   - 不要暴露完整的配置结构
	//   - 考虑在日志中使用结构化格式
	//
	// 返回：
	//   - string: 配置的字符串表示，敏感信息已脱敏
	String() string

	// Clone 创建配置的深拷贝。
	// 此方法用于创建配置对象的独立副本，修改副本不会影响原始配置。
	//
	// 使用场景：
	//   - 多个服务需要独立配置副本
	//   - 运行时配置修改需要基于配置模板
	//   - 测试中需要配置的隔离副本
	//
	// 返回：
	//   - Config: 配置对象的深拷贝
	Clone() Config
}

// Provider 配置提供者接口定义了从不同配置源加载配置的标准方式。
// 这个接口允许系统支持多种配置源（文件、环境变量、命令行参数等），
// 同时保持统一的加载接口。
//
// 配置加载优先级（从高到低）：
// 1. 命令行参数
// 2. 环境变量
// 3. 配置文件
// 4. 默认值
type Provider interface {
	// Load 从配置源加载配置。
	// 此方法应该按照优先级顺序从所有可用的配置源加载配置，
	// 并返回合并后的配置对象。
	//
	// 加载流程：
	//   1. 加载配置文件（如果存在）
	//   2. 绑定环境变量（覆盖配置文件设置）
	//   3. 应用默认值
	//   4. 验证最终配置
	//
	// 返回：
	//   - Config: 加载并验证后的配置对象
	//   - error: 加载过程中的错误，如文件不存在、格式错误等
	Load() (Config, error)

	// LoadFromEnv 仅从环境变量加载配置。
	// 此方法用于容器化部署或需要完全依赖环境变量的场景。
	// 忽略配置文件，只使用环境变量和默认值。
	//
	// 使用场景：
	//   - Kubernetes/Docker 容器部署
	//   - CI/CD 环境配置
	//   - 安全要求高的生产环境
	//
	// 返回：
	//   - Config: 基于环境变量的配置对象
	LoadFromEnv() Config

	// GetConfigPath 获取当前使用的配置文件路径。
	// 此方法用于调试和日志记录，帮助用户了解当前配置的来源。
	//
	// 返回：
	//   - string: 配置文件的绝对路径，如果没有使用配置文件则返回空字符串
	GetConfigPath() string
}
